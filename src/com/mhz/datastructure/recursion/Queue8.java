package com.mhz.datastructure.recursion;

/**
 * 8皇后的问题
 * <p>
 * 问题介绍
 * 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于
 * 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即： 任意两个皇后都不能处于同一行 、
 * 同一列或同一斜线上，问有多少种摆法(92)。
 * <p>
 * 思路分析
 * 1,第一个皇后先放第一行第一列
 * 2. 第二个皇后放在第二行 第一列,判断是否ok , 如果不ok, 继续放第二行 第二列 第三列.
 * 依次把所有列都放完, 找到一个合适的
 * 3. 继续第三个皇后, 还是第一列 , 第二列 .直到第8个皇后 也能放在一个不冲突的位置, 算是找到一个正确解
 * 4. 当得到一个正确解时, 在栈回退到上一个栈时, 就会开始回溯, 即将第一个皇后, 放到第一列的所有正确解
 * 全部得到
 * 5. 然后回头继续第一个皇后放第二列, 后面继续循环执行  1 2 3 4 的步骤
 * <p>
 * <p>
 * 说明, 理论上应该创建一个二维数组来表示棋盘, 但是实际上可以通过算法,用一个一维数组 即可解决问题,
 * arr[8]={0,4,7,5,2,6,1,3}  对应arr 下标表示第几行 , 即第几个皇后
 * arr[i]=val , val 表示第i+1 个皇后, 放在第 i+1行的 第 val +1 列
 */
public class Queue8 {
    // 定义一个max 表示共有多少个皇后
    int max = 8;
    // 定义一个数组, 保存皇后放置位置的结果  比如 arr={0,4,7,5,2,6,1,3}
    int[] array = new int[8];


    /**
     * 查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突
     *
     * @param n 表示第n个皇后
     */
    private void judge(int n) {

        for (int i = 0; i < n; i++) {

        }

    }

}
